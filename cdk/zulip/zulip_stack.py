from aws_cdk import (
    aws_ec2,
    aws_elasticloadbalancingv2,
    aws_iam,
    core
)

from oe_patterns_cdk_common import (
    Util,
    Vpc
)

# AMI list generated by:
# make AMI_ID=ami-07bb5101b6910f67d ami-ec2-copy
# on Mon Mar 14 19:44:16 UTC 2022.
AMI_ID="ami-07bb5101b6910f67d"
AMI_NAME="test"
generated_ami_ids = {
    "us-east-1": "ami-07bb5101b6910f67d"
}
# End generated code block.

class ZulipStack(core.Stack):

    def __init__(self, scope: core.Construct, id: str, **kwargs) -> None:
        super().__init__(scope, id, **kwargs)

        # vpc
        vpc = Vpc(
            self,
            "Vpc"
        )

        # asg
        asg = Asg(self, "asg")

        ami_mapping={
            "AMI": {
                "OEZULIP": AMI_NAME
            }
        }
        for region in generated_ami_ids.keys():
            ami_mapping[region] = { "OEZULIP": generated_ami_ids[region] }
        aws_ami_region_map = core.CfnMapping(
            self,
            "AWSAMIRegionMap",
            mapping=ami_mapping
        )


        #
        # PARAMETERS
        #

        alb_ingress_cidr_param = core.CfnParameter(
            self,
            "AlbIngressCidr",
            allowed_pattern="^((\d{1,3})\.){3}\d{1,3}/\d{1,2}$",
            default="0.0.0.0/0",
            description="Optional: VPC IPv4 CIDR block to restrict public access to ALB (default is 0.0.0.0/0 which is open to internet)."
        )

        alb_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AlbSg",
            group_description="{}/AlbSg".format(core.Aws.STACK_NAME),
            vpc_id=vpc.id()
        )
        core.Tags.of(alb_sg).add("Name", "{}/AlbSg".format(core.Aws.STACK_NAME))
        alb_http_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpIngress",
            cidr_ip=alb_ingress_cidr_param.value_as_string,
            description="Allow HTTP traffic to ALB from anyone",
            from_port=80,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=80
        )
        alb_https_ingress = aws_ec2.CfnSecurityGroupIngress(
            self,
            "AlbSgHttpsIngress",
            cidr_ip=alb_ingress_cidr_param.value_as_string,
            description="Allow HTTPS traffic to ALB from anyone",
            from_port=443,
            group_id=alb_sg.ref,
            ip_protocol="tcp",
            to_port=443
        )
        alb = aws_elasticloadbalancingv2.CfnLoadBalancer(
            self,
            "AppAlb",
            scheme="internet-facing",
            security_groups=[ alb_sg.ref ],
            subnets=vpc.public_subnet_ids(),
            type="application"
        )
        http_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpListener",
            # These are updated in the override below to fix case of properties - see below
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    redirect_config=aws_elasticloadbalancingv2.CfnListener.RedirectConfigProperty(
                        host="#{host}",
                        path="/#{path}",
                        port="443",
                        protocol="HTTPS",
                        query="#{query}",
                        status_code="HTTP_301"
                    ),
                    type="redirect"
                )
            ],
            load_balancer_arn=alb.ref,
            port=80,
            protocol="HTTP"
        )
        # CDK generates ActionProperty with lowercase properties - need to override due to following error:
        # Stack operations on resource HttpListener would fail starting from 03/01/2021 as the template has invalid properties.
        # Please refer to the resource documentation to fix the template.
        # Properties validation failed for resource HttpListener with message:
        # #/DefaultActions/0: required key [Type] not found
        # #/DefaultActions/0: extraneous key [type] is not permitted
        # #/DefaultActions/0: extraneous key [redirectConfig] is not permitted
        http_listener.add_override(
            "Properties.DefaultActions",
            [
                {
                    'Type': 'redirect',
                    'RedirectConfig': {
                        'Host': "#{host}",
                        'Path': "/#{path}",
                        'Port': "443",
                        'Protocol': "HTTPS",
                        'Query': "#{query}",
                        'StatusCode': "HTTP_301"
                    }
                }
            ]
        )

        https_target_group = aws_elasticloadbalancingv2.CfnTargetGroup(
            self,
            "AsgHttpsTargetGroup",
            health_check_enabled=None,
            health_check_interval_seconds=None,
            port=443,
            protocol="HTTPS",
            target_group_attributes=[
                aws_elasticloadbalancingv2.CfnTargetGroup.TargetGroupAttributeProperty(
                    key='deregistration_delay.timeout_seconds',
                    value='10'
                )
            ],
            target_type="instance",
            vpc_id=vpc.id()
        )
        https_listener = aws_elasticloadbalancingv2.CfnListener(
            self,
            "HttpsListener",
            certificates=[
                aws_elasticloadbalancingv2.CfnListener.CertificateProperty(
                    certificate_arn=certificate_arn_param.value_as_string
                )
            ],
            default_actions=[
                aws_elasticloadbalancingv2.CfnListener.ActionProperty(
                    target_group_arn=https_target_group.ref,
                    type="forward"
                )
            ],
            load_balancer_arn=alb.ref,
            port=443,
            protocol="HTTPS"
        )

        # app
        app_sg = aws_ec2.CfnSecurityGroup(
            self,
            "AppSg",
            group_description="{}/App".format(core.Aws.STACK_NAME),
            vpc_id=vpc.id()
        )
        core.Tags.of(app_sg).add("Name", "{}/AppSg".format(core.Aws.STACK_NAME))
        app_instance_role = aws_iam.CfnRole(
            self,
            "AppInstanceRole",
            assume_role_policy_document=aws_iam.PolicyDocument(
                statements=[
                    aws_iam.PolicyStatement(
                        effect=aws_iam.Effect.ALLOW,
                        actions=[ "sts:AssumeRole" ],
                        principals=[ aws_iam.ServicePrincipal("ec2.amazonaws.com") ]
                    )
                ]
            ),
            policies=[
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "logs:CreateLogStream",
                                    "logs:DescribeLogStreams",
                                    "logs:PutLogEvents"
                                ],
                                resources=[
                                    access_log_group.attr_arn,
                                    error_log_group.attr_arn,
                                    system_log_group.attr_arn
                                ]
                            )
                        ]
                    ),
                    policy_name="AllowStreamLogsToCloudWatch"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "ec2:DescribeVolumes",
                                    "ec2:DescribeTags",
                                    "cloudwatch:GetMetricStatistics",
                                    "cloudwatch:ListMetrics",
                                    "cloudwatch:PutMetricData"
                                ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="AllowStreamMetricsToCloudWatch"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[
                                    "s3:Get*",
                                    "s3:Head*"
                                ],
                                resources=[ pipeline_artifact_bucket_arn ]
                            )
                        ]
                    ),
                    policy_name="AllowGetFromArtifactBucket",
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "autoscaling:Describe*" ],
                                resources=[ "*" ]
                            )
                        ]
                    ),
                    policy_name="AllowDescribeAutoScaling"
                ),
                aws_iam.CfnRole.PolicyProperty(
                    policy_document=aws_iam.PolicyDocument(
                        statements=[
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "secretsmanager:GetSecretValue" ],
                                resources=[
                                    core.Token.as_string(
                                        core.Fn.condition_if(
                                            secret_arn_exists_condition.logical_id,
                                            secret_arn_param.value_as_string,
                                            secret.ref
                                        )
                                    ),
                                    # TODO: could this be done without repeating the list?
                                    config_secret_constructs['AUTH_KEY'].ref,
                                    config_secret_constructs['AUTH_SALT'].ref,
                                    config_secret_constructs['LOGGED_IN_KEY'].ref,
                                    config_secret_constructs['LOGGED_IN_SALT'].ref,
                                    config_secret_constructs['NONCE_KEY'].ref,
                                    config_secret_constructs['NONCE_SALT'].ref,
                                    config_secret_constructs['SECURE_AUTH_KEY'].ref,
                                    config_secret_constructs['SECURE_AUTH_SALT'].ref
                                ]
                            ),
                            aws_iam.PolicyStatement(
                                effect=aws_iam.Effect.ALLOW,
                                actions=[ "secretsmanager:ListSecrets" ],
                                resources=[ "*" ],
                            ),
                        ]
                    ),
                    policy_name="WordPressSecretAccessPolicy"
                )
            ],
            managed_policy_arns=[
                "arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore"
            ]
        )
        instance_profile = aws_iam.CfnInstanceProfile(
            self,
            "AppInstanceProfile",
            roles=[ app_instance_role.ref ]
        )

        # autoscaling
        with open("wordpress/app_launch_config_user_data.sh") as f:
            app_launch_config_user_data = f.read()
        launch_config = aws_autoscaling.CfnLaunchConfiguration(
            self,
            "AppLaunchConfig",
            image_id=core.Fn.find_in_map("AWSAMIRegionMap", core.Aws.REGION, "OEWORDPRESS"),
            instance_type=app_instance_type_param.value_as_string,
            iam_instance_profile=instance_profile.ref,
            key_name=core.Token.as_string(
                core.Fn.condition_if(
                    asg_key_name_exists_condition.logical_id,
                    asg_key_name_param.value_as_string,
                    core.Aws.NO_VALUE
                )
            ),
            security_groups=[app_sg.ref],
            user_data=(
                core.Fn.base64(
                    core.Fn.sub(
                        app_launch_config_user_data,
                        {
                            "WordPressEnv": word_press_env_param.value_as_string,
                            "WordPressHome": core.Token.as_string(
                                core.Fn.condition_if(
                                    word_press_hostname_exists_condition.logical_id,
                                    word_press_hostname_param.value_as_string,
                                    alb.attr_dns_name
                                )
                            ),
                            "SecretArn": core.Token.as_string(
                                core.Fn.condition_if(
                                    secret_arn_exists_condition.logical_id,
                                    secret_arn_param.value_as_string,
                                    secret.ref
                                )
                            ),
                            "Prefix": "{}/wordpress/secret".format(core.Aws.STACK_NAME)
                        }
                    )
                )
            )
        )
        asg = aws_autoscaling.CfnAutoScalingGroup(
            self,
            "AppAsg",
            launch_configuration_name=launch_config.ref,
            desired_capacity=core.Token.as_string(asg_desired_capacity_param.value),
            max_size=core.Token.as_string(asg_max_size_param.value),
            min_size=core.Token.as_string(asg_min_size_param.value),
            target_group_arns=[
                https_target_group.ref
            ],
            vpc_zone_identifier=vpc.private_subnet_ids()
        )
        asg.cfn_options.creation_policy=core.CfnCreationPolicy(
            resource_signal=core.CfnResourceSignal(
                count=1,
                timeout="PT15M"
            )
        )
        asg.cfn_options.update_policy=core.CfnUpdatePolicy(
            auto_scaling_rolling_update=core.CfnAutoScalingRollingUpdate(
                min_instances_in_service=1,
                pause_time="PT15M",
                wait_on_resource_signals=True
            ),
            auto_scaling_scheduled_action=core.CfnAutoScalingScheduledAction(
                ignore_unmodified_group_size_properties=True
            )
        )
        core.Tags.of(asg).add("Name", "{}/AppAsg".format(core.Aws.STACK_NAME))
